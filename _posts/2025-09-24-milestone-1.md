---
layout: post
title: Milestone 1
---

## <span style="color:#1E90FF;">Data Acquisition Tutorial</span>

code related to it:
`ift6758/data/acquisition.py`
`ift6758/data/acquisition.ipynb`

### **Introduction**

Data analytics plays an important role in sports today. Teams and coaches use data to understand player performance and make better decisions during games.
Since hockey is one of the most important sports in Canada, it is a great subject to explore using data analytics.

To start any analysis, we first need to collect detailed information about each game.
For every event that happens in a game, the NHL records the **time**, **event type**, **location**, **players involved**, and other relevant information.
This data can be accessed through the *play-by-play* API, which is structured as:
https://api-web.nhle.com/v1/gamecenter/{GAME_ID}/play-by-play

---

### **The GAME_ID Format**

Each game in the NHL is assigned a unique `GAME_ID` that encodes the **season**, **game type**, and **game number**.
The format and meaning of the digits are as follows:

- The first 4 digits represent the starting year of the season.
  For example, a game played in March 2018 still belongs to the 2017–2018 season and starts with 2017.

- The next 2 digits specify the type of game:
  - `01` = preseason
  - `02` = regular season
  - `03` = playoffs
  - `04` = all-star games

- The last 4 digits identify the specific game number.

  - For **regular-season** games, this number ranges from 0001 up to the total number of games in that season.

  - For **playoff** games, these digits have additional meaning:
    - The second digit indicates the playoff round (R1–R4).
    - The third digit identifies the matchup number within that round.
    - The fourth digit specifies the game number within the best-of-seven series.

**Example:**
`2022030411` corresponds to the *2022–2023 playoffs*, round 4 , matchup 1, and game 1.

---

### **Goal and Workflow**

The goal of this step is to collect the NHL play-by-play data using the official API and store it locally in a structured format.
We designed a Python program that can automatically download both regular-season and playoff games, while avoiding repeated downloads by checking if files already exist.


Our program follows these main steps:

1. Build the correct `GAME_ID` for each game in a season.
2. Check if the file already exists locally.
3. If not, send a request to the API to download the JSON data.
4. Save the data in a folder organized by season and game type (regular or playoff).

---

### **Function Overview**



#### `write_json()`
This function takes a Python dictionary (the JSON response from the API) and writes it to a local .json file.
It automatically creates folders if they don’t exist, ensuring that data from each season is saved in the correct directory.

#### `read_json()`
This function  loads an existing .json file from disk and returns its contents as a Python dictionary.
By using this function, the program can skip unnecessary downloads if the file is already available locally.




#### `get_game()`
This is the core function of the program.
It takes a single `GAME_ID` and an output directory as inputs.
The function first checks if the game’s file already exists; if yes, it loads it from disk.
Otherwise, it requests the data from the NHL API, saves it locally using `write_json()`, and returns the downloaded data.
This logic ensures that the process is both efficient and repeatable.

#### `download_regular()`
This function automates the downloading process for an entire **regular season**.
It generates all possible `GAME_ID`s with the prefix , it calls `get_game()` to fetch and save the data if it is not already present.
The files are stored in folders like: dataStore/year/regular/

Using an upper bound of around 1,312 games per season safely covers all possible games.

#### `download_playoff()`
This function handles the **playoff data**.
It uses the prefix `03` for playoff `GAME_ID`s, the last three digits include the **round number (1–4)**, the **matchup number**, and the **game number (1–7)**.
Each playoff year starts with **eight matchups** in Round 1, followed by four in Round 2, two in Round 3, and one in Round 4.
The function systematically generates each `GAME_ID` for all rounds and matchups, and downloads them with `get_game()`.
The results are stored under:
dataStore/<year>/playoff/


#### `download_all()`
This is a simple wrapper function that combines both previous functions.
It downloads all regular-season and playoff games for a given year with a single command.
For example:


`download_all(2016, "./dataStore")`

This command automatically creates the correct folder structure and collects every game from the 2016–2017 season.


## <span style="color:#1E90FF;">Interactive Debugging Tool Question<span>
code related to it:
`ift6758/data/load_game.py`
`ift6758/data/debugging.ipynb`

We built a small interactive tool  using ipywidgets to browse play-by-play data game-by-game and event-by-event.
Users can choose the season year, switch between regular and playoff games, select a game ID, and scrub through events with a slider.

The two main function are:

#### `plot_ring(ring_path, play)`
This function plots a single hockey event on a rink image.
It reads the event’s coordinates from the data, draws the rink, places a point where the event happened, and labels it with the event ID.
It also adds a title showing the period, time, and event type.

---

#### `on_game_change(root, ring_path, year_widget, season_widget, game_widget, event_widget, out=None)`
This function defines how the interactive tool reacts when the user changes any widget (season, game, or event).
It loads the selected game data, updates the event range, and refreshes the output area to show the event summary and the updated rink plot.


Here is what our interactive tool looks like:
![interactive picture](public/milestone1/interactive.png)

The rink diagram  displays the event location.
This example corresponds to **Event #52**, a **faceoff** occurring at the start of the first period (**P1 00:00**) in Game ID 1194 (2016 season).

- **Teams:** BOS (Home) vs OTT (Away)
- **Final Score:** BOS 1 – OTT 2
- **Shots on Goal:** BOS 29  \|  OTT 26

